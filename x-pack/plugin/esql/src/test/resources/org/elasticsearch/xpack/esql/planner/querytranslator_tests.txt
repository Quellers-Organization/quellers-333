// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License
// 2.0; you may not use this file except in compliance with the Elastic License
// 2.0.

//
// Query translator tests. Format:
//
// <name>[-Ignore]
// <esql-query-line1>
// [<esql-query-line2>
// ...
// <esql-query-line-n];
// [<matcher-1> <expectation-1>EOL
// <matcher-2> <expectation-2>EOL
// ...
// ]
// ;
//
// Notes:
//   - The ESQL query can span multiple lines and should be terminated with semicolon (;)
//   - The currently supported matchers: `CONTAINS` (the default one), `REGEX`
//   - To ignore a test, add -Ignore to the end of the name
//   - Matchers can be skipped, if you just want to test that a query is optimized/plan without errors
//   - Do not use whitespaces in the relevant parts of the query itself, as they will be removed.
//     For example to match: '"params":{"v0":"point","v1":"point( 10 20 )"}
//     you should use: "point(1020)" instead of "point( 10 20 )", otherwise the assertion will fail.

// Binary comparisons
///////////////

greaterInt
FROM test | WHERE 10 < integer;
"esql_single_value":{"field":"integer","next":{"range":{"integer":{"gt":10,
;

greaterEqualDouble
FROM test | WHERE 10.0 <= double;
esql_single_value":{"field":"double","next":{"range":{"double":{"gte":10.0,
;

lessDatetime
FROM test | WHERE "2007-12-03T10:15:30+01:00" > date;
"esql_single_value":{"field":"date","next":{"range":{"date":{"lt":1196673330000,"time_zone":"Z",
;

lessUnsignedLong
FROM test | WHERE 2147483648::unsigned_long > unsigned_long;
"esql_single_value":{"field":"unsigned_long","next":{"range":{"unsigned_long":{"lt":2147483648,
;

lessEqualLong
FROM test | WHERE 2147483648 >= long;
"esql_single_value":{"field":"long","next":{"range":{"long":{"lte":2147483648,
;

equalVersionString
FROM test | WHERE version == "1.2.3";
"esql_single_value":{"field":"version","next":{"term":{"version":{"value":"1.2.3"
;

equalKeyword
FROM test | WHERE keyword == "foo";
"esql_single_value":{"field":"keyword","next":{"term":{"keyword":{"value":"foo"
;

equalDatetime
FROM test | WHERE "2007-12-03T10:15:30+01:00" == date;
"esql_single_value":{"field":"date","next":{"term":{"date":{"value":1196673330000}
;

notEqualIp
FROM test | WHERE ip != "127.0.0.1";
"esql_single_value":{"field":"ip","next":{"bool":{"must_not":[{"term":{"ip":{"value":"127.0.0.1"
;

// Range queries
///////////////
// Note: Currently binary comparisons are not combined into range queries, so we get bool queries with multiple one
// sided ranges for now.

orRangeInt
FROM test | WHERE 10 < integer OR integer < 12;
// Once we combine binary comparisons, this query should be trivial.
REGEX .*should.*"esql_single_value":\{"field":"integer".*"range":\{"integer":\{"gt":10,.*"esql_single_value":\{"field":"integer".*"range":\{"integer":\{"lt":12
;

andRangeInt
FROM test | WHERE 10 < integer AND integer < 12;
REGEX .*must.*"esql_single_value":\{"field":"integer".*"range":\{"integer":\{"gt":10,.*"range":\{"integer":\{"lt":12
;

andRangeDouble
FROM test | WHERE 10.9 < double AND double < 12.1;
REGEX .*must.*"esql_single_value":\{"field":"double".*"range":\{"double":\{"gt":10.9,.*"range":\{"double":\{"lt":12.1
;

andRangeDatetime
FROM test | WHERE "2007-12-03T10:15:30+01:00" < date AND date < "2024-01-01T10:15:30+01:00";
REGEX .*must.*"esql_single_value":\{"field":"date".*"range":\{"date":\{"gt":1196673330000,.*"range":\{"date":\{"lt":1704100530000,
;

andRangeUnsignedLong
FROM test | WHERE 2147483648::unsigned_long < unsigned_long AND unsigned_long < 2147483650::unsigned_long;
REGEX .*must.*"esql_single_value":\{"field":"unsigned_long".*"range":\{"unsigned_long":\{"gt":2147483648,.*"range":\{"unsigned_long":\{"lt":2147483650,
;
