[[esql-examples]]
== {esql} examples

++++
<titleabbrev>Examples</titleabbrev>
++++


[discrete]
=== Aggregate and enrich Windows event logs

[source,esql]
----
FROM logs-*
| WHERE event.code IS NOT NULL
| STATS event_code_count = COUNT(event.code) BY event.code,host.name
| ENRICH win_events ON event.code WITH event_description
| WHERE event_description IS NOT NULL and host.name IS NOT NULL
| RENAME event_description AS event.description
| SORT event_code_count DESC
| KEEP event_code_count,event.code,host.name,event.description
----

.Show example with comments
[%collapsible]
====
[source,esql]
----
// Query logs from indices matching logs-*
FROM logs-*
// Filter out events where event.code is null
| WHERE event.code IS NOT NULL
// Aggregate the count of events by event.code and host.name
| STATS event_code_count = COUNT(event.code) BY event.code,host.name
// Enrich events with info from event_description
| ENRICH win_events ON event.code WITH event_description
// Filter out events where event_description or host.name is null
| WHERE event_description IS NOT NULL and host.name IS NOT NULL
// Rename event_description for consistency
| RENAME event_description AS event.description
// Sort results by event_code_count in descending order
| SORT event_code_count DESC
// Keep only the specified fields
| KEEP event_code_count,event.code,host.name,event.description
----
====

.Show line-by-line explanation
[%collapsible%open]
====
* Query logs from indices that match the pattern `logs-*`.
* Filter out events where the `event.code` field is null.
* Aggregate the count of events by `event.code` and `host.name`.
* Enrich the events with additional information using the `event_description` field.
* Filter out events where `event_description` or `host.name` is null.
* Rename `event_description` to `event.description` to match the field naming convention.
* Sort the results by `event_code_count` in descending order.
* Keep only the specified fields: `event_code_count`, `event.code`, `host.name`, and `event.description`.
====

[discrete]
=== Sum outbound traffic from process `curl.exe`

[source,esql]
----
FROM logs-endpoint
| WHERE process.name == "curl.exe"
| STATS bytes = SUM(destination.bytes) BY destination.address
| EVAL kb =  bytes/1024
| SORT kb DESC
| LIMIT 10
| KEEP kb,destination.address
----

.Show example with comments
[%collapsible]
====
[source,esql]
----
// Query the logs-endpoint source
FROM logs-endpoint
// Filter for events with a process.name of curl.exe
| WHERE process.name == "curl.exe"
// Calculate the sum of bytes sent to destination addresses
| STATS bytes = SUM(destination.bytes) BY destination.address
// Convert the sum to kilobytes (kb)
| EVAL kb =  bytes/1024
// Sort results by kb in descending order
| SORT kb DESC
// Limit the results to 10
| LIMIT 10
// Keep only the specified fields
| KEEP kb,destination.address
----
====

.Show line-by-line explanation
[%collapsible%open]
====
* Query logs from the `logs-endpoint` source.
* Filter the results for events with a `process.name` of `curl.exe`.
* Calculate the sum of bytes sent to destination addresses.
* Convert the sum to kilobytes (KB).
* Sort the results by `kb` (kilobytes) in descending order.
* Limit the output to the top 10 results.
* Keep only the `kb` and `destination.address` fields.
====

[discrete]
=== Analyze DNS logs to find domains with high numbers of unique DNS queries

[source,esql]
----
FROM logs-*
| GROK dns.question.name "%{DATA}\\.%{GREEDYDATA:dns.question.registered_domain:string}"
| STATS unique_queries = COUNT_DISTINCT(dns.question.name) BY dns.question.registered_domain, process.name
| WHERE unique_queries > 10
| SORT unique_queries DESC
| RENAME unique_queries AS `Unique Queries`, dns.question.registered_domain AS `Registered Domain`, process.name AS `Process`
----

.Show example with comments
[%collapsible]
====
[source,esql]
----
// Query logs from indices matching logs-*
FROM logs-*
// Use GROK to extract the registered domain from dns.question.name
| GROK dns.question.name "%{DATA}\\.%{GREEDYDATA:dns.question.registered_domain:string}"
// Calculate count of unique DNS queries per registered domain and process name
| STATS unique_queries = COUNT_DISTINCT(dns.question.name) BY dns.question.registered_domain, process.name
// Limit to results with more than 10 unique_queries
| WHERE unique_queries > 10
// Sort by unique_queries in descending order
| SORT unique_queries DESC
// Rename fields for clarity
| RENAME unique_queries AS `Unique Queries`, dns.question.registered_domain AS `Registered Domain`, process.name AS `Process`
----
====

.Show line-by-line explanation
[%collapsible%open]
====
* Query logs from indices that match the pattern `logs-*`.
* Use a <<esql-process-data-with-grok,grok>> pattern to extract the registered domain from the `dns.question.name` field.
* Calculate the count of unique DNS queries per registered domain and process name.
* Limit to results where the number of `unique_queries` is greater than 10.
* Sort the results by `unique_queries` in descending order.
* Rename fields for clarity: `unique_queries` to `Unique Queries`, `dns.question.registered_domain` to `Registered Domain`, and `process.name` to `Process`.
====

[discrete]
=== Find high volumes of outbound user connections

[source,esql]
----
FROM logs-*
| WHERE NOT CIDR_MATCH(destination.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16")
| STATS destcount = COUNT(destination.ip) BY user.name, host.name
| ENRICH ldap_lookup_new ON user.name
| WHERE group.name IS NOT NULL
| EVAL follow_up = CASE(destcount >= 100, "true","false")
| SORT destcount DESC
| KEEP destcount, host.name, user.name, group.name, follow_up
----

.Show example with comments
[%collapsible]
====
[source,esql]
----
// Query logs from indices matching logs-*
FROM logs-*
// Exclude destination IPs in private ranges
| WHERE NOT CIDR_MATCH(destination.ip, "10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16")
// Calculate count of unique destination IPs by user.name and host.name
| STATS destcount = COUNT(destination.ip) BY user.name, host.name
// Enrich user.name with LDAP info
| ENRICH ldap_lookup_new ON user.name
// Filter out results where group.name is null
| WHERE group.name IS NOT NULL
// Create a follow_up field that is true when destcount is greater than or equal to 100
| EVAL follow_up = CASE(destcount >= 100, "true","false")
// Sort results by destcount in descending order
| SORT destcount DESC
// Keep only the specified fields
| KEEP destcount, host.name, user.name, group.name, follow_up
----
====

.Show line-by-line explanation
[%collapsible%open]
====
* Query logs from indices that match the pattern `logs-*`.
* Filter out events where the destination IP address falls within private IP address ranges (specifically, `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`).
* Calculate the count of unique destination IPs by `user.name` and `host.name`.
* Enrich the `user.name` field with LDAP group information.
* Filter out results where `group.name` is null.
* Use a `CASE` statement to create a `follow_up` field, setting it to `true` when `destcount` is greater than or equal to 100. Otherwise, `follow_up` is `false`.
* Sort the results by `destcount` in descending order.
* Keep only the specified fields: `destcount`, `host.name`, `user.name`, `group.name`, and `follow_up`.
====