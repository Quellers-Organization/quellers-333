[role="xpack"]
[[security-api-query-role]]
=== Query Role API

++++
<titleabbrev>Query Role</titleabbrev>
++++

Retrieves roles with <<query-dsl,Query DSL>> in a <<paginate-search-results,paginated>> fashion.

[[security-api-query-role-request]]
==== {api-request-title}

`GET /_security/_query/role`

`POST /_security/_query/role`

[[security-api-query-role-prereqs]]
==== {api-prereq-title}

* To use this API, you must have at least the  `read_security` cluster privilege.

[[security-api-query-role-desc]]
==== {api-description-title}

The role management APIs are generally the preferred way to manage roles, rather than using
<<roles-management-file,file-based role management>>.
The query roles API does not retrieve roles that are defined in roles files.
You can optionally filter the results with a query. Also, the results can be paginated and sorted.

[[security-api-query-role-request-body]]
==== {api-request-body-title}

You can specify the following parameters in the request body:

`query`::
(Optional, string) A <<query-dsl,query>> to filter which roles to return.
The query supports a subset of query types, including
<<query-dsl-match-all-query,`match_all`>>, <<query-dsl-bool-query,`bool`>>,
<<query-dsl-term-query,`term`>>, <<query-dsl-terms-query,`terms`>>,
<<query-dsl-match-query,`match`>>, <<query-dsl-ids-query,`ids`>>,
<<query-dsl-prefix-query,`prefix`>>, <<query-dsl-wildcard-query,`wildcard`>>,
<<query-dsl-exists-query,`exists`>>, <<query-dsl-range-query,`range`>>,
and <<query-dsl-simple-query-string-query,`simple query string`>>.
+
You can query the following values associated with a role.
+
.Valid values for `query`
[%collapsible%open]
====
`name`::
The <<security-api-put-role-path-params,name>> of the role, which is internally indexed as a keyword.

`description`::
The <<defining-roles,description>> of the role, which is internally indexed as a text.

`metadata`::
Metadata field associated with the <<defining-roles,role>>, such as `metadata.app_tag`.
Note that metadata is internally indexed as a <<flattened,flattened>> field type.
This means that all sub-fields act like `keyword` fields when querying and sorting.
It also implies that it is not possible to refer to a subset of metadata fields using wildcard patterns,
e.g. `metadata.field*`, even for query types that support field name patterns.
Lastly, all the metadata fields can be searched together when simply mentioning the
`metadata` field (i.e. not followed by any dot and sub-field name).

`applications`::
The list of <<roles-application-priv,application privileges>> that the role grants.
These are all internally indexed as keywords.

`application`:::
The name of the application associated to the privileges and resources.

`privileges`:::
The names of the privileges that the role grants.

`resources`:::
The resources to which the privileges apply.

====

include::{es-ref-dir}/rest-api/common-parms.asciidoc[tag=from]
+
By default, you cannot page through more than 10,000 hits using the `from` and
`size` parameters. To page through more hits, use the
<<search-after,`search_after`>> parameter.

`size`::
(Optional, integer) The number of hits to return. Must not be negative and defaults to `10`.
+
By default, you cannot page through more than 10,000 hits using the `from` and
`size` parameters. To page through more hits, use the
<<search-after,`search_after`>> parameter.

`sort`::
(Optional, object) <<sort-search-results,Sort definition>>. You can sort on `username`, `roles` or `enabled`.
In addition, sort can also be applied to the `_doc` field to sort by index order.

`search_after`::
(Optional, array) <<search-after,Search after>> definition.


[[security-api-query-role-response-body]]
==== {api-response-body-title}

This API returns the following top level fields:

`total`::
The total number of roles found.

`count`::
The number of roles returned in the response.

`roles`::
A list of roles that match the query.

[[security-api-query-role-example]]
==== {api-examples-title}

The following request lists all roles, assuming you have the
`read_security` privilege:

[source,console]
----
GET /_security/_query/role
----
// TEST[setup:admin_role,user_role]

A successful call returns a JSON structure that contains the information
retrieved for one or more roles:

[source,console-result]
----
{
    "total": 2,
    "count": 2,
    "users": [ <1>
        {
            "username": "jacknich",
            "roles": [
                "admin",
                "other_role1"
            ],
            "full_name": "Jack Nicholson",
            "email": "jacknich@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true
        },
        {
            "username": "sandrakn",
            "roles": [
                "admin",
                "other_role1"
            ],
            "full_name": "Sandra Knight",
            "email": "sandrakn@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true
        }
    ]
}
----
// NOTCONSOLE

<1> The list of roles that were retrieved for this request

If you create a user with the following details:

[source,console]
----
POST /_security/user/jacknich
{
  "password" : "l0ng-r4nd0m-p@ssw0rd",
  "roles" : [ "admin", "other_role1" ],
  "full_name" : "Jack Nicholson",
  "email" : "jacknich@example.com",
  "metadata" : {
    "intelligence" : 7
  }
}
----

A successful call returns a JSON structure:

[source,console-result]
----
{
  "created": true
}
----

Use the user information retrieve the user with a query:

[source,console]
----
GET /_security/_query/user
{
    "query": {
        "prefix": {
            "roles": "other"
        }
    }
}
----
// TEST[setup:jacknich_user]
A successful call returns a JSON structure for a user:

[source,console-result]
--------------------------------------------------
{
    "total": 1,
    "count": 1,
    "users": [
        {
            "username": "jacknich",
            "roles": [
                "admin",
                "other_role1"
            ],
            "full_name": "Jack Nicholson",
            "email": "jacknich@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true
        }
    ]
}
--------------------------------------------------
// NOTCONSOLE

To retrieve the user `profile_uid` as part of the response:

[source,console]
--------------------------------------------------
GET /_security/_query/user?with_profile_uid=true
{
    "query": {
        "prefix": {
            "roles": "other"
        }
    }
}
--------------------------------------------------
// TEST[setup:jacknich_user]

[source,console-result]
--------------------------------------------------
{
    "total": 1,
    "count": 1,
    "users": [
        {
            "username": "jacknich",
            "roles": [
                "admin",
                "other_role1"
            ],
            "full_name": "Jack Nicholson",
            "email": "jacknich@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true,
            "profile_uid": "u_79HkWkwmnBH5gqFKwoxggWPjEBOur1zLPXQPEl1VBW0_0"
        }
    ]
}
--------------------------------------------------
// NOTCONSOLE

Use a `bool` query to issue complex logical conditions and use
`from`, `size`, `sort` to help paginate the result:

[source,js]
----
GET /_security/_query/user
{
  "query": {
    "bool": {
      "must": [
        {
          "wildcard": {
            "email": "*example.com" <1>
          }
        },
        {
          "term": {
            "enabled": true <2>
          }
        }
      ],
      "filter": [
        {
          "wildcard": {
            "roles": "*other*" <3>
          }
        }
      ]
    }
  },
  "from": 1, <4>
  "size": 2, <5>
  "sort": [
    { "username": { "order": "desc"} } <6>
  ]
}
----
// NOTCONSOLE

<1> The email must end with `example.com`
<2> The user must be enabled
<3> The result will be filtered to only contain users with at least one role that contains the substring `other`
<4> The offset to begin the search result is the 2nd (zero-based index) user
<5> The page size of the response is 2 users
<6> The result is sorted by `username` in descending order

The response contains a list of matched users along with their sort values:

[source,js]
----
{
    "total": 5,
    "count": 2,
    "users": [
        {
            "username": "ray",
            "roles": [
                "other_role3"
            ],
            "full_name": "Ray Nicholson",
            "email": "rayn@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true,
            "_sort": [
                "ray" <1>
            ]
        },
        {
            "username": "lorraine",
            "roles": [
                "other_role3"
            ],
            "full_name": "Lorraine Nicholson",
            "email": "lorraine@example.com",
            "metadata": {
                "intelligence": 7
            },
            "enabled": true,
            "_sort": [
                "lorraine"
            ]
        }
    ]
}
----
// NOTCONSOLE

<1> The sort value is `username`
